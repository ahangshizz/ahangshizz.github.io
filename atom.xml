<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>道阻且长</title>
  
  <subtitle>行则将至</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-09T04:36:48.216Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>魏行</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++多态与函数重载重写浅谈</title>
    <link href="http://yoursite.com/2019/05/09/C-%E5%A4%9A%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2019/05/09/C-多态与函数重载重写浅谈/</id>
    <published>2019-05-09T04:36:10.000Z</published>
    <updated>2019-05-09T04:36:48.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-多态理解"><a href="#C-多态理解" class="headerlink" title="C++多态理解"></a>C++多态理解</h2><p><strong>多态的实现效果</strong><br>多态：同样的调用语句有多种不同的表现形态；<br><a id="more"></a><br><strong>多态实现的三个条件</strong><br>    有继承、有virtual重写、有父类指针（引用）指向子类对象。<br><strong>多态的C++实现</strong><br>   virtual关键字，告诉编译器这个函数要支持多态；不是根据指针类型判断如何调用；而是要根据指针所指向的实际对象类型来判断如何调用<br><strong>多态的理论基础</strong><br>   动态联编PK静态联编。根据实际的对象类型来判断重写函数的调用。<br><strong>多态的重要意义</strong><br>   设计模式的基础 是框架的基石。<br><strong>实现多态的理论基础</strong><br>  函数指针做函数参数<br>C函数指针是C++至高无上的荣耀。C函数指针一般有两种用法（正、反）。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p><em>必须在同一个类中进行<br>子类无法重载父类的函数，父类同名函数将被名称覆盖<br>重载是在编译期间根据参数类型和个数决定函数调用</em></p><h2 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h2><p><em>必须发生于父类与子类之间<br>并且父类与子类中的函数必须有完全相同的原型<br>使用virtual声明之后能够产生多态(如果不使用virtual，那叫重定义)<br>多态是在运行期间根据具体对象的类型决定函数调用</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-多态理解&quot;&gt;&lt;a href=&quot;#C-多态理解&quot; class=&quot;headerlink&quot; title=&quot;C++多态理解&quot;&gt;&lt;/a&gt;C++多态理解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;多态的实现效果&lt;/strong&gt;&lt;br&gt;多态：同样的调用语句有多种不同的表现形态；&lt;br&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令整理</title>
    <link href="http://yoursite.com/2019/05/08/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/08/Linux基本命令整理/</id>
    <published>2019-05-08T05:39:50.000Z</published>
    <updated>2019-05-08T05:47:48.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux基本命令整理"><a href="#Linux基本命令整理" class="headerlink" title="Linux基本命令整理"></a>Linux基本命令整理</h2><p><strong>1.目录基本操作</strong><br>根目录的基本示意图<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20190508130203181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FfaGFuZ19zeno=,size_16,color_FFFFFF,t_70" alt="根目录的示意图"><br><strong>根目录下各种目录的作用</strong><br><strong>dev目录(device的缩写)</strong><br>            <em>设备目录,该目录下的所有文件称为设备文件<br>            Linux下一切皆文件(CPU,显卡,声卡,网卡,鼠标,键盘)</em><br><strong>etc目录</strong><br>        <em>包含了当前操作系统用户的所有配置的相关信息</em><br><strong>home目录</strong><br>        <em>当前操作系统所安装的用户的主目录</em><br><em>家目录(宿主目录,主用户目录)</em><br><strong>lib目录</strong><br>        <em>操作系统使用的库文件已经相关的配置都放在此目录下</em><br><strong>mnt目录</strong><br>        <em>手动挂载的目录</em><br><strong>media目录</strong><br>        <em>系统自动挂载的目录</em><br><strong>usr目录</strong><br>        <em>软件资源包管理目录,存放当前用户下的一些东西</em><br><strong>bin目录</strong><br>        <em>Linux操作系统可执行的系统级的二进制命令<br>        shell解析输入的命令时,会进入到该目录执行对应的二进制命令</em><br><strong>root目录</strong><br>        <em>root用户的家目录</em><br><strong>run目录</strong><br>        <em>存放系统运行时需要的一些文件</em><br><strong>proc目录</strong><br>        <em>内核提供的一个接口,主要用来系统统计信息</em></p><ol><li><p>ls 命令<br>-a 查看列出目录下所有文件内容<br>-l 列出文件的所有详细信息</p></li><li><p>cd命令<br>进入指定的目录<br>cd .. 进入上一级目录<br>cd . 当前目录<br>cd - 进入到上次cd的目录<br>cd ~进入当前用户的家目录</p></li><li><p>pwd命令<br>查看当前所在目录</p></li><li><p>mkdir命令<br>mkdir+文件名  创建一个指定名字的目录</p></li><li><p>rmdir命令<br>rmdir+目录名      删除该目录(只能删除空目录)</p></li><li><p>touch命令<br>摸一下文件,如果没有该文件直接创建该文件</p></li><li><p>cp命令<br>cp file1.txt file2.txt把文件1的内容拷贝到文件2,如果文件不存在创建文件,如果存在覆盖原内容<br>cp -r dir1 dir2     循环拷贝目录1的内容到目录2,目录二不存在自动创建</p></li></ol><p><em>要进入一个目录必须要有**</em>读权限<strong>,<em>而要对一个文件或目录进行修改删除,必须拥有</em></strong>读写权限<strong></strong>其他系统命令<strong><br>    1.top<br>    查看CPU资源<br>    2.fdisk<br>    查看磁盘<br>    3.df<br>    查看磁盘使用情况<br>    4.du<br>    查看文件占用空间大小<br>    5.free<br>    查看内存使用情况    </strong>Linux下的安装命令**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install 需要安装的软件名</span><br></pre></td></tr></table></figure><p>如果提示权限不够则命令前面加上sudo</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux基本命令整理&quot;&gt;&lt;a href=&quot;#Linux基本命令整理&quot; class=&quot;headerlink&quot; title=&quot;Linux基本命令整理&quot;&gt;&lt;/a&gt;Linux基本命令整理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.目录基本操作&lt;/strong&gt;&lt;br&gt;根目录的基本示意图&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>插入排序与希尔排序</title>
    <link href="http://yoursite.com/2019/05/07/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/05/07/插入排序与希尔排序/</id>
    <published>2019-05-07T04:21:34.000Z</published>
    <updated>2019-05-07T04:23:27.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>插入排序效率最高的时候是这个序列的元素有基本的顺序(如果是升序排列)即是小数在大多在前面,大数大多在后面.还有就是这个序列的元素不要太多</strong><br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20190507120328994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FfaGFuZ19zeno=,size_16,color_FFFFFF,t_70" alt="插入排序的基本思路"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];<span class="comment">//保存以防丢失数据</span></span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; arr[j]; --j) &#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[MAX];</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) &#123;</span><br><span class="line">arr[i] = rand() % MAX;</span><br><span class="line">&#125;</span><br><span class="line">Print_Arr(arr, MAX);</span><br><span class="line">InsertSort(arr, MAX);</span><br><span class="line">Print_Arr(arr, MAX);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>希尔排序像是插入排序的升级版<br>把数组分组以后再进行插入排序<br>分组的次数是:increasement=sizeof(arr)/3+1<br>分组排序以后序列会有一个大致的顺序<br>最后进行全排序</strong><br><img src="https://img-blog.csdnimg.cn/20190507121525351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FfaGFuZ19zeno=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> increasement = len;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="comment">//为了让最后一次全排列可以执行到使用do while语句</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//计算出这个数列需要分的组数</span></span><br><span class="line">increasement = increasement / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; increasement; ++i) &#123;</span><br><span class="line"><span class="comment">//与插入排序完全相同,只是把插入排序的增量1换成increasement</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + increasement; j &lt; len; j += increasement) &#123;</span><br><span class="line"><span class="keyword">int</span> tem = arr[j];</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[j - increasement]) &#123;</span><br><span class="line"><span class="keyword">for</span> (k = j - increasement; k &gt;= <span class="number">0</span>&amp;&amp;tem&lt;arr[k]; k -= increasement) &#123;</span><br><span class="line">arr[k + increasement] = arr[k];</span><br><span class="line">&#125;</span><br><span class="line">arr[k + increasement] = tem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (increasement&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_ShellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"------------------------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[MAX];</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) &#123;</span><br><span class="line">arr[i] = rand() % MAX;</span><br><span class="line">&#125;</span><br><span class="line">Print_ShellSort(arr, MAX);</span><br><span class="line">ShellSort(arr, MAX);</span><br><span class="line">Print_ShellSort(arr, MAX);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;插入排序效率最高的时候是这个序列的元素有基本的顺序(如果是升序排列)即是小数在大多在前面,大数大多在后面.还有就是这个序列的元素不要太多&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的非递归遍历,排序算法效率,Linux基本命令</title>
    <link href="http://yoursite.com/2019/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/05/07/二叉树的非递归遍历-排序算法效率-Linux基本命令/</id>
    <published>2019-05-07T00:44:52.000Z</published>
    <updated>2019-05-07T00:47:01.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的非递归遍历和Linux基本操作"><a href="#二叉树的非递归遍历和Linux基本操作" class="headerlink" title="二叉树的非递归遍历和Linux基本操作"></a>二叉树的非递归遍历和Linux基本操作</h2><p>1.二叉树的非递归遍历<br>使用栈模型,利用先进后出的思想,把根节点带上FALSE的标志放入栈中,然后循环进行出栈入栈<br>①判断栈中元素是否为空,若栈中元素为空,则循环结束<br>②判断栈顶元素的标志是TRUE还是FALSE若为FALSE出栈以后找到他的左子树结点和右子数结点按顺序入栈(根据先进后出的原则,如果想要先序遍历,则先入右子数,再左子数,再根结点),此时根节点再次入栈时需要把根节点的标志改为TRUE,<br>③此方法值需要改变入栈顺序即可改变遍历的顺序<br><a id="more"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LinkStack.h"</span><span class="comment">//自己创建的栈模型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_FALSE 0<span class="comment">//标志</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_TRUE 1<span class="comment">//标志</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CinaryNode</span> &#123;</span><span class="comment">//二叉树的结点</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CinaryNode</span>* <span class="title">Lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CinaryNode</span>* <span class="title">Rchild</span>;</span></span><br><span class="line">&#125;CinaryNode;</span><br><span class="line"><span class="comment">//创建一个结构体封装结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">LinkNode* node;</span><br><span class="line">CinaryNode* root;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line">&#125;StackNode;</span><br><span class="line"><span class="comment">//用二叉树的结点的创建栈的结点</span></span><br><span class="line"><span class="function">StackNode* <span class="title">BuyNode</span><span class="params">(CinaryNode* root,<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">StackNode* node = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">node-&gt;root = root;</span><br><span class="line">node-&gt;flag = flag;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉树的非递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Tree</span><span class="params">(CinaryNode* root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建栈</span></span><br><span class="line">LinkStack* <span class="built_in">stack</span> = Init_LinkStack();</span><br><span class="line"><span class="comment">//把根节点传入栈中</span></span><br><span class="line">Push_LinkStack(<span class="built_in">stack</span>, (LinkNode*)BuyNode(root, MY_FALSE));</span><br><span class="line"><span class="keyword">while</span> (Size_LinkStack(<span class="built_in">stack</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">StackNode* node = (StackNode*)Top_LinkStack(<span class="built_in">stack</span>);</span><br><span class="line">Pop_LinkStack(<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">if</span> (node-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;flag == MY_TRUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, node-&gt;root-&gt;ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//当前结点的右结点入栈</span></span><br><span class="line">Push_LinkStack(<span class="built_in">stack</span>, (LinkNode*)BuyNode(node-&gt;root-&gt;Rchild, MY_FALSE));</span><br><span class="line"><span class="comment">//当前结点的左节点入栈</span></span><br><span class="line">Push_LinkStack(<span class="built_in">stack</span>, (LinkNode*)BuyNode(node-&gt;root-&gt;Lchild, MY_FALSE));</span><br><span class="line"><span class="comment">//改变当前结点的状态,再入栈</span></span><br><span class="line">node-&gt;flag = MY_TRUE;</span><br><span class="line">Push_LinkStack(<span class="built_in">stack</span>, (LinkNode*)node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉树的递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Tree_ByDG</span><span class="params">(CinaryNode*root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;ch);</span><br><span class="line">Print_Tree_ByDG(root-&gt;Lchild);</span><br><span class="line">Print_Tree_ByDG(root-&gt;Rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestCinaryNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line">CinaryNode node1 = &#123; <span class="string">'A'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node2 = &#123; <span class="string">'B'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node3 = &#123; <span class="string">'C'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node4 = &#123; <span class="string">'D'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node5 = &#123; <span class="string">'E'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node6 = &#123; <span class="string">'F'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node7 = &#123; <span class="string">'G'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node8 = &#123; <span class="string">'H'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node9 = &#123; <span class="string">'I'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line">CinaryNode node10 = &#123; <span class="string">'J'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="comment">//建立数据之间的关系</span></span><br><span class="line">node1.Lchild = &amp;node2;</span><br><span class="line">node1.Rchild = &amp;node3;</span><br><span class="line">node2.Lchild = &amp;node4;</span><br><span class="line">node2.Rchild = &amp;node5;</span><br><span class="line">node4.Lchild = &amp;node8;</span><br><span class="line">node4.Rchild = &amp;node9;</span><br><span class="line">node5.Lchild = &amp;node10;</span><br><span class="line">node3.Lchild = &amp;node6;</span><br><span class="line">node3.Rchild = &amp;node7;</span><br><span class="line"><span class="comment">//二叉树的非递归打印</span></span><br><span class="line">&#123;</span><br><span class="line">Print_Tree(&amp;node1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用递归方式打印对比</span></span><br><span class="line">Print_Tree_ByDG(&amp;node1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TestCinaryNode();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.冒泡排序和选择排序的对比</strong><br>冒泡排序相对于选择排序来说效率较低<strong>原因在于</strong><br><em>①根据冒泡排序的原则,每次进行排序时都都要进行大量的数值交换<br>②选择法排序可优化为一次循环只交换一次<br>设置一个最小值下标的变量命名为min,如果在内层循环有数小更小min则记录这个数的下标,在内层循环结束时,只需要把min记录下标的那个值与外层循环下标的数进行交换即可,在进行很多数据的排序时,两个排序算法的效率会对比出来</em><br><strong>3.Linux的基本命令操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">匹配查找命令：</span><br><span class="line">grep 在指定文件查找带有指定字符串的行</span><br><span class="line">   -n 显示行号</span><br><span class="line">   -i 忽略大小写</span><br><span class="line">   -v 反向匹配</span><br><span class="line">   -R 递归对指定目录下的所有文件进行字符串匹配</span><br><span class="line">find 在指定目录下查找文件</span><br><span class="line">-name 通过文件名查找文件</span><br><span class="line">-type 通过文件类型查找文件</span><br><span class="line">f d p l s b c </span><br><span class="line">-size +/-[unit]</span><br><span class="line">系统资源命令：</span><br><span class="line">top 查看CPU资源</span><br><span class="line">fdisk 查看磁盘</span><br><span class="line">df 查看磁盘使用情况</span><br><span class="line">du  查看文件占用空间大小</span><br><span class="line"><span class="built_in">free</span> 查看内存使用情况</span><br><span class="line">时间命令：</span><br><span class="line">cal查看日历</span><br><span class="line">-n 查看附近几个月日历</span><br><span class="line">-y 查看全年日历</span><br><span class="line">-j 查看day-of-year</span><br><span class="line">date 查看系统时间</span><br><span class="line">-s 设置系统时间</span><br><span class="line"> + 以指定格式显示时间</span><br><span class="line">='%s' 显示时间戳</span><br><span class="line">    man     查看手册</span><br><span class="line">        man ls</span><br><span class="line">        </span><br><span class="line">    su      切换用户</span><br><span class="line">        su test</span><br><span class="line">        </span><br><span class="line">    ifconfig查询ip地址</span><br><span class="line">halt关机</span><br><span class="line">shutdown -h now 立即关机</span><br><span class="line">reboot 重启</span><br><span class="line">Ctrl+c </span><br><span class="line"></span><br><span class="line">shell命令及运行原理</span><br><span class="line">shell是什么----------命令行解释器</span><br><span class="line">用户为什么不能直接使用shell:</span><br><span class="line">解释用户功能--解释操作系统执行结果</span><br><span class="line">shell命令是什么</span><br><span class="line">对操作系统 的封装,一个一个程序</span><br><span class="line"></span><br><span class="line">权限:</span><br><span class="line">Linux下的用户分类:</span><br><span class="line">普通用户:添加用户 useradd -m weihang   </span><br><span class="line">  passwd weihang</span><br><span class="line">root用户</span><br><span class="line">文件的权限:</span><br><span class="line">  文件操作分用户:</span><br><span class="line">文件所有者文件所属组其他用户</span><br><span class="line">ugo</span><br><span class="line">  对用户分操作</span><br><span class="line">可读     可写 可执行</span><br><span class="line"> r        w        x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在操作系统中使用二进制的比特位存储权限信息</span><br><span class="line"><span class="number">111</span> <span class="number">111</span> <span class="number">101</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">umask 掩码</span><br><span class="line">最终权限=给定权限&amp;(~掩码)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改文件权限:</span><br><span class="line">chmod <span class="number">777</span> 文件名</span><br><span class="line">chmod u-x 文件名 </span><br><span class="line">chmod u+w 文件名</span><br><span class="line"></span><br><span class="line">沾滞位权限:</span><br><span class="line">其他用户在设置了沾滞位权限的目录下可以创建文件,删除自己的文件,但不能删除别人的文件</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树的非递归遍历和Linux基本操作&quot;&gt;&lt;a href=&quot;#二叉树的非递归遍历和Linux基本操作&quot; class=&quot;headerlink&quot; title=&quot;二叉树的非递归遍历和Linux基本操作&quot;&gt;&lt;/a&gt;二叉树的非递归遍历和Linux基本操作&lt;/h2&gt;&lt;p&gt;1.二叉树的非递归遍历&lt;br&gt;使用栈模型,利用先进后出的思想,把根节点带上FALSE的标志放入栈中,然后循环进行出栈入栈&lt;br&gt;①判断栈中元素是否为空,若栈中元素为空,则循环结束&lt;br&gt;②判断栈顶元素的标志是TRUE还是FALSE若为FALSE出栈以后找到他的左子树结点和右子数结点按顺序入栈(根据先进后出的原则,如果想要先序遍历,则先入右子数,再左子数,再根结点),此时根节点再次入栈时需要把根节点的标志改为TRUE,&lt;br&gt;③此方法值需要改变入栈顺序即可改变遍历的顺序&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开始记录学习生活</title>
    <link href="http://yoursite.com/2019/05/06/%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/"/>
    <id>http://yoursite.com/2019/05/06/开始记录学习生活/</id>
    <published>2019-05-06T03:36:47.000Z</published>
    <updated>2019-05-06T03:40:07.049Z</updated>
    
    <content type="html"><![CDATA[<p>这是我用了一天多时间搭建的博客,搭建这个博客的目的在于记录学习生活,记录每天<br>都学到了什么,学习的路是很漫长的,但我坚信一句话”道阻且长,行则将至”,以后要坚<br>持每天都用这种方式记录自己的学习生活.加油</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我用了一天多时间搭建的博客,搭建这个博客的目的在于记录学习生活,记录每天&lt;br&gt;都学到了什么,学习的路是很漫长的,但我坚信一句话”道阻且长,行则将至”,以后要坚&lt;br&gt;持每天都用这种方式记录自己的学习生活.加油&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建博客真快乐</title>
    <link href="http://yoursite.com/2019/05/06/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9C%9F%E5%BF%AB%E4%B9%90/"/>
    <id>http://yoursite.com/2019/05/06/搭建博客真快乐/</id>
    <published>2019-05-06T01:31:46.000Z</published>
    <updated>2019-05-06T01:32:38.376Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个博客真开心,希望会成功吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;搭建一个博客真开心,希望会成功吧&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
